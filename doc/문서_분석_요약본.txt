================================================================================
패션 Agentic AI 가상 피팅 POC 개발 계획서 - 분석 요약본
================================================================================

생성 일시: 2025년
최종 보완: 2026년 2월 (코드베이스 분석 및 POC 대비 구현 현황 반영)

분석 대상 문서:
  - doc/infor.md (계획서 본문과 동일한 내용, 메인 참조 문서)
  - doc/패션 Agentic AI 가상 피팅 POC 개발 계획서.pdf (10페이지, 저장소에는 미포함.
    동일 내용은 doc/infor.md로 확인 가능)

================================================================================
1. 프로젝트 기본 정보
================================================================================

프로젝트명: 패션 Agentic AI 가상 피팅 POC 개발
문서 버전: 3.0
팀명: MAS(Multi-Agent System) 팀
개발 기간: 약 3개월 (착수일 ~ 2026년 1월 말)

================================================================================
2. 프로젝트 개요 및 핵심 목표
================================================================================

2.1 PoC 정의
-------------
'패션 AI 가상 피팅 에이전트' 개발의 첫 단계인 PoC(기술 검증) 단계로, 기존 보유 
기술인 '2D to 3D 자동 변환 기술'을 핵심 엔진으로 활용하되, 단순 기능 호출 방식이 
아닌 지능형 에이전트(Intelligent Agent)가 주도적으로 전체 프로세스를 
오케스트레이션하는 방식의 기술적 타당성을 검증하는 것을 핵심 목표로 함.

2.2 에이전트 작동 원리
-----------------------
- 인식(Perception): 사용자의 복합적인 의도 파악
- 판단(Judgment): 최적의 작업 계획 수립
- 행동(Action): 필요한 기술 모듈(도구)을 자율적으로 사용하여 결과 생성

================================================================================
3. 시스템 아키텍처
================================================================================

3.1 전체 구조
-------------
'인식-판단-행동'의 3단계 흐름을 중심으로 구성된 멀티 에이전트 시스템

주요 구성 요소:
  • Custom UI: 사용자가 텍스트와 이미지를 입력하는 인터페이스
  • Agent Runtime: AI 에이전트의 판단 및 계획을 실행하는 핵심 오케스트레이션 엔진
  • F.LLM (Foundation LLM): 사용자의 의도를 파악하고 작업 계획을 생성하는 두뇌
  • Data Stores (RAG): 에이전트의 판단 정확도를 높이기 위한 외부 지식 저장소
  • Extensions (Tools): 2D/3D 변환 등 실제 작업을 수행하는 독립적인 기술 모듈

3.2 작동 원리 (3단계 프로세스)
-------------------------------
1. 인식 (Perception)
   - 사용자가 UI를 통해 텍스트와 2D 의류 이미지 입력
   - 멀티모달 모델(VLM)이 입력을 분석하여 최종 목표 인지

2. 판단 (Judgment / Orchestration)
   - 종합 감독 에이전트(Agent 1): 큰 그림의 작업 계획 수립
     예: 의류 이미지 분석 → 3D 모델 생성 → 렌더링
   - 작업 지시 전문가 에이전트(Agent 2): 구체적인 도구(API) 호출 순서와 
     파라미터를 담은 JSON 형식의 실행 계획 생성

3. 행동 (Action)
   - Agent Runtime이 실행 계획에 따라 필요한 Extensions(도구)를 순차 호출
   - 최종 생성된 3D 가상 피팅 결과물을 사용자 UI의 3D 뷰어에 시각화

================================================================================
4. PoC 개발 범위 정의
================================================================================

전체 아키텍처 중 PoC 단계에서는 핵심 기술 파이프라인의 작동 여부를 확인하는 데 
집중하여 범위를 전략적으로 축소함.

4.1 범위 축소 내역
------------------
┌──────────────────┬──────────────────────────────┬──────────────────────────────┐
│ 구분              │ 전체 아키텍처                │ PoC 범위                       │
├──────────────────┼──────────────────────────────┼──────────────────────────────┤
│ 핵심 경로         │ [경로 A: 3D 생성]과          │ [경로 A: 3D 생성] 단일 경로      │
│                  │ [경로 B: 옷 추천] 모두 처리   │ 에만 집중                       │
├──────────────────┼──────────────────────────────┼──────────────────────────────┤
│ 에이전트 판단 근거│ RAG를 통한 동적 지식 참조    │ 사전 정의된 단순 규칙/데이터         │
│                  │                              │ (JSON) 참조 (Mock RAG)       │
├──────────────────┼──────────────────────────────┼──────────────────────────────┤
│ 에이전트 기억      │ 장기/단기 메모리 모두 활용    │ 단기 메모리(Session-based)만      │
├──────────────────┼──────────────────────────────┼──────────────────────────────┤
│ 자기 수정         │ 시각적 평가 및 복잡한 재계획  │ 성공/실패 여부만 판단하여           │
│ (Reflection)     │                              │ 단순 재시도(1회) 수행           │
├──────────────────┼──────────────────────────────┼──────────────────────────────┤
│ 사용 도구 (Tools) │ 다양한 Extensions 및         │ '2D to 3D 자동 변환' 관련        │
│                  │ Function 도구 사용           │ 핵심 단일 도구 체인에 한정        │
└──────────────────┴──────────────────────────────┴──────────────────────────────┘

4.2 범위 축소 사유
------------------
• 에이전트의 3D 생성 오케스트레이션 능력 검증에 모든 리소스 집중
• RAG 파이프라인 구축의 복잡성 배제하고 '판단-실행' 프로세스 자체 검증 우선
• 단일 작업의 완결성에 집중하여 장기 메모리 기능은 파일럿 단계로 이연
• 도구 실행의 성공/실패라는 명확한 기술적 기준만으로 안정성 검증
• 가장 복잡하고 핵심적인 도구를 성공적으로 호출하고 제어할 수 있는지 집중 검증

================================================================================
5. 단계별 개발 계획 (3개월)
================================================================================

┌──────────┬──────────────┬─────────────────────────────────────────────┐
│ 단계      │ 기간         │ 주요 활동                                    │
├──────────┼──────────────┼─────────────────────────────────────────────┤
│ 1단계:    │ 착수 후      │ • POC 목표 및 범위 확정                       │
│ 준비 및   │ 1개월 차     │ • 기본 개발 환경 및 프레임워크 구축              │
│ 설계      │              │ • 핵심 에이전트 아키텍처 설계                  │
├──────────┼──────────────┼─────────────────────────────────────────────┤
│ 2단계:    │ 착수 후      │ • 2D, 3D 모듈 API 연동                        │
│ 핵심 개발  │ 2개월 차     │ • 5대 핵심 디자인 패턴 구현                    │
│          │              │ • 기본 데이터 플로우 파이프라인 구축             │
├──────────┼──────────────┼─────────────────────────────────────────────┤
│ 3단계:    │ 착수 후      │ • 최종 렌더링 UI 개발 및 통합                   │
│ 통합 및   │ 3개월 차     │ • 전체 시스템 통합 테스트                       │
│ 검증      │              │ • 내부 루브릭 기반 성능 평가                   │
├──────────┼──────────────┼─────────────────────────────────────────────┤
│ 4단계:    │ 01월 말      │ • POC 개발 결과 및 성과 정리                   │
│ 최종 보고  │              │ • 대표 보고 및 파일럿 단계 전환 논의            │
└──────────┴──────────────┴─────────────────────────────────────────────┘

================================================================================
6. 핵심 아키텍처 패턴 및 기술 스택
================================================================================

6.1 핵심 아키텍처 설계 패턴
---------------------------
본 PoC는 Google 등에서 검증된 업계 표준의 에이전트 설계 사상을 기반으로 개발.

[PoC 단계 적용 패턴 - 5개]
  목표: AI 에이전트의 기본적인 기술 파이프라인 조율 능력 검증
  
  1. 프롬프트 체이닝 (Prompt Chaining)
     - 복잡한 작업을 여러 단순 단계로 나누어 순차 처리
     - 예: '2D 이미지 분석 → 3D 모델 변환 → 3D 렌더링'
  
  2. 라우팅 (Routing)
     - 사용자 입력에 따라 다음 실행 작업(경로)을 동적으로 결정
     - 예: "재질 변경" 요청 → '재질 변경' 도구 선택
  
  3. 도구 사용 (Tool Use)
     - 외부 API나 내부 함수 같은 '도구'를 호출하여 실제 작업 수행
     - 예: '2D-to-3D 변환 모듈' API 호출
  
  4. 반성 (Reflection)
     - 생성한 결과물이 올바른지 스스로 검증하고 평가
     - 예: 3D 변환 후 결과 파일 정상 생성 여부 확인
  
  5. 복구 (Resilience & Recovery)
     - 오류 발생 시 감지하고 시스템이 멈추지 않도록 대처
     - 예: 3D 변환 API 호출 실패 시 최대 1회 재시도

[향후 확장 계획]
  Pilot 단계에서 나머지 16개의 GDP 패턴을 점진적으로 도입하여 서비스 고도화 예정

6.2 주요 기술 스택
------------------
┌──────────────────┬─────────────────────────────┬──────────────────────────────┐
│ 구분             │ 설계 패턴 구현 역할          │ 주요 기술 스택               │
├──────────────────┼─────────────────────────────┼──────────────────────────────┤
│ AI 에이전트      │ 프롬프트 체이닝, 라우팅,     │ LangChain, LlamaIndex        │
│ 프레임워크       │ 도구 사용 등 GDP 패턴 구현   │                              │
├──────────────────┼─────────────────────────────┼──────────────────────────────┤
│ 대규모 언어 모델 │ 사용자 의도 이해(인식),      │ Google Gemini, OpenAI GPT   │
│ (LLM)            │ 작업 계획 수립(판단)         │                              │
├──────────────────┼─────────────────────────────┼──────────────────────────────┤
│ API 및 도구      │ '도구 사용' 패턴에 따른      │ FastAPI (API 서버),          │
│                  │ 기능 모듈 호출               │ 자체 2D-3D 변환 모듈         │
├──────────────────┼─────────────────────────────┼──────────────────────────────┤
│ 데이터 저장소    │ '메모리 관리', '지식 검색'   │ Vector DB                    │
│                  │ 패턴 구현                    │ (Chroma, Pinecone)           │
├──────────────────┼─────────────────────────────┼──────────────────────────────┤
│ 프론트엔드       │ 사용자 인터페이스 및         │ React, Vue.js                │
│                  │ 3D 결과물 시각화             │ (3D 뷰어 라이브러리 포함)    │
├──────────────────┼─────────────────────────────┼──────────────────────────────┤
│ 프로토콜         │ 에이전트 간 표준화된 통신    │ Google A2A Protocol,        │
│                  │ 및 협업 지원                 │ MCP (Model Context Protocol) │
└──────────────────┴─────────────────────────────┴──────────────────────────────┘

================================================================================
7. 루브릭: 단계별 내부 평가 기준
================================================================================

본 PoC의 성공 여부를 객관적으로 판단하기 위한 내부 평가 기준:

┌──────────────────────┬────────────────────────────┬──────────────────────────┐
│ 평가 항목            │ 측정 기준                   │ 목표 수준                │
├──────────────────────┼────────────────────────────┼──────────────────────────┤
│ 아키텍처 설계의      │ 설계된 아키텍처가 모듈식    │ 향후 타 기술로 교체 및   │
│ 적절성               │ 확장성(MSA) 원칙 준수 여부  │ 확장이 용이한 유연한 구조│
│                      │ 동료 검토                   │ 확보                     │
├──────────────────────┼────────────────────────────┼──────────────────────────┤
│ 핵심 패턴 구현       │ 5대 핵심 디자인 패턴이      │ 각 패턴 정상 작동 및     │
│ 완성도               │ 의도대로 정확히 작동하는지  │ 테스트 커버리지 80% 이상 │
│                      │ 단위/통합 테스트로 검증     │ 달성                     │
├──────────────────────┼────────────────────────────┼──────────────────────────┤
│ 시스템 성능 및       │ • 성공률: 전체 프로세스를   │ • 성공률: 85% 이상       │
│ 안정성               │   오류 없이 완료하는 비율   │ • 처리 시간: 30초 이내   │
│                      │ • 처리 시간: 사용자 입력부터│                          │
│                      │   최종 결과 출력까지의      │                          │
│                      │   평균 시간                │                          │
├──────────────────────┼────────────────────────────┼──────────────────────────┤
│ 모듈 교체 용이성     │ 특정 핵심 모듈(예: 3D 엔진) │ 1일 이내                 │
│                      │ 을 다른 모듈로 교체하는 데  │                          │
│                      │ 소요되는 시간              │                          │
└──────────────────────┴────────────────────────────┴──────────────────────────┘

================================================================================
8. Agent Design Patterns 단계별 적용 로드맵
================================================================================

본 프로젝트는 Google 등에서 제시하는 21개의 Agent Design Patterns를 기반으로 
단계별 로드맵에 따라 시스템을 고도화함.

8.1 PoC 단계 적용 패턴 (5개) - 시스템의 기본 골격 구축
-------------------------------------------------------
위 6.1 섹션 참조

8.2 Pilot 1단계 적용 예정 패턴 (16개) - 서비스 고도화 및 지능 확장
-------------------------------------------------------------------
  6. 병렬화: 여러 작업을 동시에 실행하여 처리 시간 단축
  7. 계획: 사용자 프롬프트 분석하여 최적 작업 계획 능동적 수립
  8. 다중 에이전트 협업: 각기 다른 전문성 에이전트들이 협력하여 문제 해결
  9. 메모리 관리: 사용자 과거 대화/선호도 기억하여 개인화 경험 제공
  10. 지식 검색 (RAG): 외부 DB 최신 정보 검색하여 판단 정확도 향상
  11. 가드레일/안전: 부적절한 요청 차단하고 안전한 범위 내 작동 보장
  12. 평가 및 모니터링: 시스템 성능 지속적으로 측정하고 추적
  13. 자원 인식 최적화: 작업 복잡도에 따라 비용 효율적 자원 동적 선택
  14. 인간 참여 루프: AI 판단 불확실 시 사람 개입 요청하여 결정 안정성 향상
  15. 에이전트 간 통신 (A2A): 표준화된 프로토콜로 에이전트 간 데이터 교환
  16. 목표 설정 및 모니터링: 장기 목표나 제약 조건을 대화 내내 추적
  17. 우선순위 지정: 여러 요청 시 중요도에 따라 처리 순서 동적 관리
  18. 추론 기법 (CoT 등): 논리적 사고 과정으로 복잡한 질문에 합리적 답변
  19. 학습과 적응: 사용자 피드백과 상호작용 경험으로 점진적 성능 개선
  20. 탐험과 발견: 새로운 지식/트렌드 능동적 탐색하여 지식 기반 확장
  21. 모델 컨텍스트 프로토콜 (MCP): 확장된 표준 인터페이스로 외부 도구 연동

8.3 Pilot 2단계 적용 예정 - 서비스 고도화 및 자율 운영 체계 구축
-----------------------------------------------------------------
  1. 패턴 융합 및 시너지 극대화
     - 개별 패턴들을 복합적으로 연계하여 1+1=3 이상의 시너지 창출
     - 예: 다중 에이전트 협업 + 우선순위 지정 + 자원 최적화

  2. 자율적 목표 추론 및 장기 계획 수행
     - 사용자 단편적 요청을 넘어 암시적 장기 목표를 스스로 추론
     - 여러 세션에 걸쳐 목표 달성을 위한 계획 능동적 수행

  3. 선제적 상호작용 및 개인화 심화
     - 사용자 요청 전에 필요 예측하여 유용한 정보 제안하는 
       '프로액티브(Proactive)' 에이전트로 진화

  4. 엔터프라이즈급 최적화 및 안정성 확보
     - 대규모 사용자 감당 가능하도록 비용, 성능, 안정성 극한 최적화
     - 시스템 스스로 이상 상황에 대처하는 회복탄勉强성 강화

================================================================================
9. 핵심 강점 및 차별화 포인트
================================================================================

9.1 Agentic AI 패러다임의 장점
-------------------------------
기존 LLM Workflow나 RAG 방식과 달리, 여러 에이전트가 자율적으로 협력하는 
Agentic AI 패러다임을 채택하여 '역할 분담을 통한 팀플레이'가 가능함.

• 총괄 감독 에이전트(Agent 1): 전략 수립
• 작업 지시 전문가 에이전트(Agent 2): 전략 구체화
• 도구(Extensions): 실제 작업 수행

이를 통해 단일 에이전트로는 해결하기 어려운 복잡한 문제를 더 안정적으로 해결 가능.

9.2 업계 표준 기반 설계
-----------------------
Google 등에서 검증된 21개의 Agent Design Patterns를 기반으로 한 체계적이고 
확장 가능한 아키텍처 설계

9.3 단계적 확장 계획
--------------------
PoC → Pilot 1단계 → Pilot 2단계로 이어지는 명확한 단계별 로드맵과 각 단계별 
구체적인 목표 및 평가 기준 수립

================================================================================
10. 기대 효과 및 성공 지표
================================================================================

10.1 기술적 검증 목표
---------------------
• 에이전트 기반 3D 생성 오케스트레이션 기술의 타당성 입증
• 모듈식 아키텍처(MSA)를 통한 확장 가능한 시스템 구조 확보
• 업계 표준 패턴 기반의 안정적인 시스템 구현

10.2 성능 목표
--------------
• 성공률: 85% 이상
• 처리 시간: 30초 이내
• 테스트 커버리지: 80% 이상
• 모듈 교체 시간: 1일 이내

10.3 향후 확장 가능성
---------------------
• 파일럿 단계에서 16개의 추가 디자인 패턴 도입 예정
• 개인화, 다중 에이전트 협업, RAG 등 고도화된 기능 구현 계획
• 엔터프라이즈급 자율 운영 체계 구축 목표

================================================================================
11. 결론 및 요약
================================================================================

본 프로젝트는 '2D to 3D 자동 변환 기술'이라는 기존 핵심 기술을 바탕으로, 
Agentic AI 패러다임을 활용한 지능형 가상 피팅 시스템의 기술적 타당성을 검증하는 
PoC 단계입니다.

핵심 특징:
  • 3단계 프로세스: 인식-판단-행동
  • 멀티 에이전트 협업 시스템
  • Google 검증 표준 패턴 기반 설계
  • 단계적 확장 가능한 아키텍처

3개월의 개발 기간 동안 핵심 기술 파이프라인의 작동 여부를 집중적으로 검증하고, 
성공 시 파일럿 단계로 확장하여 실제 서비스 구현을 목표로 함.

================================================================================
12. 코드베이스 구조 및 핵심 모듈 분석
================================================================================

12.1 agentic_system 디렉토리 구조
---------------------------------
  agentic_system/
  ├── api/main.py              # FastAPI 메인: /api/v1/request, /health, 세션/파일 API
  ├── core/
  │   ├── agent_runtime.py     # Agent 1: 인식·판단·행동, 도구 등록/실행, 자기수정 루프
  │   ├── f_llm.py             # Agent 2: 추상계획→실행계획(JSON), InternVL2 래퍼, 규칙 기반 폴백
  │   ├── memory.py            # MemoryManager, ShortTermMemory(Session), LongTermMemory(예정)
  │   └── custom_ui.py         # 사용자 입력→JSON Payload, 결과 포맷팅
  ├── tools/
  │   ├── extensions.py        # 2D→3D 도구: ChatGarment 연동, analyze/generate_pattern/convert_to_3d/render
  │   ├── chatgarment_integration.py  # ChatGarment 파이프라인 래퍼
  │   ├── extensions_service.py       # 외부 ChatGarment 서비스 호출
  │   └── functions.py        # function_product_search (Mock 상품 검색)
  ├── data_stores/
  │   ├── rag.py               # Mock RAG + RAGStore (PoC용 JSON 지식베이스)
  │   └── rag_vector.py        # Vector RAG (향후 확장)
  ├── models/
  │   └── internvl2_wrapper.py # InternVL2-8B 래퍼 (Agent 2용, 현재 계획 생성은 규칙 기반)
  └── frontend/                # React + Vite, ImageUpload, StatusBar, ResultViewer, ModelViewer(3D)

12.2 데이터 플로우 (요청 처리)
-----------------------------
  1. 클라이언트 → POST /api/v1/request (text, image, session_id)
  2. main.py: 이미지 저장 → CustomUI.process_user_input() → Payload 생성
  3. AgentRuntime.process_request(payload):
     - _analyze_user_intent() → 3d_generation / garment_recommendation (라우팅)
     - _create_abstract_plan() → AbstractPlan (Agent 1 판단)
     - agent2.generate_execution_plan() → ExecutionPlan (Agent 2, 현재 규칙 기반)
     - _execute_plan() → tools_registry 도구 순차 호출
     - _self_correction_loop() → _evaluate_result() 후 실패 시 최대 1회 재시도
  4. memory.add_conversation() → ShortTermMemory에 대화 기록
  5. custom_ui.format_output(result) → JSON 응답 반환

12.3 기타 저장소 구성
--------------------
  - ChatGarment/, GarmentCodeRC/: 2D→3D 변환용 (LLaVA 기반, GarmentCode 등)
  - chatgarment_service/: 독립 FastAPI 서비스 (port 9000)
  - checkpoints/, model/InternVL2_8B/: 모델 가중치 (저장소 제외)
  - uploads/, outputs/: 업로드·출력 디렉터리

================================================================================
13. POC 개발 계획서 대비 구현 현황
================================================================================

13.1 5대 핵심 디자인 패턴 구현 여부
----------------------------------
┌─────────────────────────────┬──────────┬─────────────────────────────────────────────┐
│ 패턴                        │ 구현 여부│ 구현 위치·비고                                │
├─────────────────────────────┼──────────┼─────────────────────────────────────────────┤
│ 1. 프롬프트 체이닝          │ ✅       │ f_llm._create_3d_generation_steps() 4단계     │
│                             │          │ (analyze_image→generate_pattern→convert_to_3d│
│                             │          │ →render_result). agent_runtime 순차 실행.   │
├─────────────────────────────┼──────────┼─────────────────────────────────────────────┤
│ 2. 라우팅                   │ ✅       │ agent_runtime._analyze_user_intent()         │
│                             │          │ 3d_generation vs garment_recommendation 분기│
│                             │          │ → _create_abstract_plan(), F.LLM 단계 분기. │
├─────────────────────────────┼──────────┼─────────────────────────────────────────────┤
│ 3. 도구 사용 (Tool Use)     │ ✅       │ tools_registry, extensions_2d_to_3d,         │
│                             │          │ function_product_search. _execute_plan()에서 │
│                             │          │ tool(action, parameters, context) 호출.     │
├─────────────────────────────┼──────────┼─────────────────────────────────────────────┤
│ 4. 반성 (Reflection)        │ ✅       │ _evaluate_result(): 단계별 status 확인,      │
│                             │          │ 성공/실패 판단. PoC 범위대로 시각적 품질 X. │
├─────────────────────────────┼──────────┼─────────────────────────────────────────────┤
│ 5. 복구 (Resilience)        │ ✅       │ _self_correction_loop(): 실패 시 max_retries  │
│                             │          │ (기본 1회) 재시도.                           │
└─────────────────────────────┴──────────┴─────────────────────────────────────────────┘

13.2 PoC 범위 정의 대비 구현
---------------------------
  • 핵심 경로: [경로 A: 3D 생성] 구현됨 (extensions_2d_to_3d). 경로 B(옷 추천)는
    function_product_search Mock으로 구현되어 있음.
  • 에이전트 판단 근거: Mock RAG (rag.py) 사용. 사전 정의 JSON 규칙 참조.
  • 에이전트 기억: 단기 메모리만 (ShortTermMemory, Session-based). 장기 메모리 미구현.
  • 자기 수정: 성공/실패 판단 후 1회 재시도만 구현.
  • 사용 도구: 2D→3D 단일 도구 체인 + 상품 검색 Function 구현.

13.3 기술 스택: 계획서 vs 현재 구현
----------------------------------
┌──────────────────┬─────────────────────────────┬─────────────────────────────────────┐
│ 구분              │ 계획서 (infor.md)            │ 현재 구현                            │
├──────────────────┼─────────────────────────────┼─────────────────────────────────────┤
│ LLM              │ Google Gemini, OpenAI GPT    │ InternVL2-8B (실행계획 생성은        │
│                  │                             │ use_llm_for_now=False로 규칙 기반)  │
├──────────────────┼─────────────────────────────┼─────────────────────────────────────┤
│ 에이전트 프레임워크│ LangChain, LlamaIndex      │ 자체 AgentRuntime/F.LLM (미사용)   │
├──────────────────┼─────────────────────────────┼─────────────────────────────────────┤
│ API/도구          │ FastAPI, 자체 2D-3D 변환    │ FastAPI ✅, 2D-3D: ChatGarment+      │
│                  │                             │ GarmentCodeRC 연동                   │
├──────────────────┼─────────────────────────────┼─────────────────────────────────────┤
│ 데이터 저장소     │ Vector DB (Chroma, Pinecone)│ Mock RAG (JSON). rag_vector.py 준비. │
├──────────────────┼─────────────────────────────┼─────────────────────────────────────┤
│ 프론트엔드        │ React, Vue.js, 3D 뷰어      │ React + Vite, Three.js 기반 3D 뷰어 ✅│
├──────────────────┼─────────────────────────────┼─────────────────────────────────────┤
│ 프로토콜          │ A2A, MCP                   │ 미적용 (향후 Pilot 확장)              │
└──────────────────┴─────────────────────────────┴─────────────────────────────────────┘

13.4 미구현·축소된 부분
----------------------
  • Agent 2의 LLM 기반 실행 계획 생성: f_llm.py에서 use_llm_for_now=False로 비활성화.
  • 계획서 상 RAG: Mock만 사용, Vector RAG 미연동.
  • 장기 메모리: 클래스만 존재, PoC에서는 단기 메모리만 사용.

================================================================================
14. 향후 전환: Gemini API Try-On 및 Garment 관련 제거
================================================================================

14.1 전환 방향
-------------
  • ChatGarment, GarmentCodeRC는 제거 예정.
  • 가상 피팅(2D→3D/입혀보기) 기능은 Google Gemini API를 활용한 Try-On 방식으로
    전환할 예정입니다.

14.2 Garment 관련 삭제 가능 범위 (참고)
--------------------------------------
  아래 항목은 Try-On 전환 시 제거·대체해도 됨.
  • 도구: agentic_system/tools/extensions.py (ChatGarment/GarmentCodeRC 연동)
  • 도구: agentic_system/tools/chatgarment_integration.py, extensions_service.py
  • 서비스: agentic_system/chatgarment_service/, 루트 chatgarment_service/
  • 디렉터리: ChatGarment/, GarmentCodeRC/
  • API main.py: CHATGARMENT_SERVICE_URL, USE_CHATGARMENT_SERVICE 환경 변수 및
    extensions_2d_to_3d 도구 등록 → Gemini Try-On API 호출 도구로 교체
  • 테스트/스크립트: test_*chatgarment*, test_*3d*, analyze_chatgarment_execution.py,
    llava_infer.py, scripts/evaluate_garment*.py 등
  • RAG Mock 내 의류 타입/스타일 등 용어는 Try-On 맥락에 맞게 유지·수정 가능

  Agent 1/2, Custom UI, Memory, Mock RAG, FastAPI, 프론트엔드(3D 뷰어) 구조는
  유지하고, '2D→3D 변환' 도구만 Gemini API Try-On 호출로 교체하는 방식 권장.

14.3 전환 적용 완료 (진행 사항)
-------------------------------
  • agentic_system/tools/gemini_tryon.py 추가: Gemini API 기반 가상 피팅 도구
    (analyze_image, try_on, process_request). GEMINI_API_KEY 미설정 시 Mock 동작.
  • agentic_system/core/f_llm.py: 3D 생성 경로를 gemini_tryon 단일 단계(try_on)로 변경.
  • agentic_system/api/main.py: extensions_2d_to_3d 제거, gemini_tryon 등록.
    CHATGARMENT_SERVICE_URL/USE_CHATGARMENT_SERVICE 제거, GEMINI_API_KEY 사용.
  • agentic_system/requirements.txt: google-genai 추가.
  • ChatGarment/GarmentCodeRC 연동 코드는 미호출 상태로 유지(삭제 가능).

================================================================================
15. Gemini API 키 필요 여부 (인지·오케스트레이션·F.LLM 기준)
================================================================================

15.1 현재 구조에서의 역할 구분
-----------------------------
  • 인식 (Perception): Custom UI 입력 → Agent Runtime에서 _analyze_user_intent()
    (규칙 기반: "입혀줘"/"가상 피팅"/이미지 유무로 3d_generation vs garment_recommendation 분기)
  • 판단 (Judgment): Agent Runtime(오케스트레이션) + F.LLM(Agent 2)
    - 오케스트레이션: Agent 1 — 추상 계획 수립, 도구 실행 순서 관리
    - F.LLM: Agent 2 — 추상 계획 → JSON 실행 계획 생성. 현재 InternVL2-8B 또는 규칙 기반
  • 행동 (Action): 등록된 도구 실행 — gemini_tryon(가상 피팅), function_product_search 등

15.2 Gemini API 키가 필요한 부분
-------------------------------
  • 가상 피팅 도구 (gemini_tryon): GEMINI_API_KEY가 있으면 의류 이미지 분석(analyze_image),
    Try-On 흐름에서 Gemini Vision/생성 활용. 없으면 Mock(이미지 복사 등)으로 동작.
  → 즉, **인지/오케스트레이션/F.LLM** 자체는 현재 **Gemini API에 의존하지 않음**.

15.3 Gemini API 키가 필수는 아닌 부분
-------------------------------------
  • 인지: 규칙 기반 의도 분석만 사용 시 → Gemini API 불필요.
  • 오케스트레이션(Agent Runtime): 코드 로직만 사용 → Gemini API 불필요.
  • F.LLM(Agent 2): 현재 InternVL2-8B 또는 규칙 기반 실행 계획 생성 → Gemini API 불필요.

15.4 정리
---------
  • **지금 구현된 인지·판단(오케스트레이션 + F.LLM)** 만 쓸 경우: **Gemini API 키는 필수가 아님.**
  • **가상 피팅 결과 품질**(이미지 분석·Try-On)을 높이려면: **GEMINI_API_KEY 설정 권장.**
  • 인지·판단까지 Gemini(예: Gemini로 의도 분석·실행 계획 생성)로 교체하려면:
    그때는 해당 API 호출을 위한 **Gemini API 키가 필요**함.

================================================================================
문서 분석 완료
================================================================================

